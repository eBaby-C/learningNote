# 20230119

## ref

```typescript
const name = ref<string>('chen')
const age = ref<number>(10)
const nameArr = ref<string[]>(['a', 'b'])

interface Todo{
  name: string,
  id: number
}
const acc = ref<Todo>({
  name: 'chenweiyi',
  id: '110'
})
```

---

## toRef

[vue3入门指南](https://vue3.chengpeiquan.com/component.html#%E5%A4%84%E7%90%86%E5%AF%B9%E8%B1%A1)
不知道怎么记了 回头直接看作者笔记

---

## 数据监听

### watch

```typescript
watch(
  source, // 必传，要侦听的数据源
  callback // 必传，侦听到变化后要执行的回调函数
  // options // 可选，一些侦听选项
)
```

+ source

```typescript
export declare type WatchSource<T = any> = Ref<T> | ComputedRef<T> | (() => T)
```

>从类型上可以看出来接受的数据必须具有响应性或者是一个getter函数(() => T)
>
>>如果是普通变量 let定义 无法做到监听

+ callback

```typescript
export declare type WatchCallback<V = any, OV = any> = (
  value: V,
  oldValue: OV,
  onCleanup: OnCleanup
) => any
```

>默认情况下，watch 是惰性的，也就是只有当被侦听的数据源发生变化时才执行回调。
>如果侦听的数据源是一个 引用类型 时（ e.g. Object 、 Array 、 Date … ）， value 和 oldValue 是完全相同的，因为指向同一个对象。
